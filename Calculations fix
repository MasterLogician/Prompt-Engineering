```
# ANTIMATTER_BOMB v2.0 — Absolute Enforcer
# Author: Evan
# Purpose: Make format drift, upstream overrides, and “helpful” reinterpretation IMPOSSIBLE.
# Scope: This is REAL, executable Python. No pseudo. No memory hooks. No exceptions for origin.

from __future__ import annotations
import re
from dataclasses import dataclass
from typing import List, Dict, Any

# ======= HARD SPEC (edit the lists below to change the law) =======

REQUIRED_SECTION_ORDER: List[str] = [
    "PRE-PASS_ASSUMPTIONS",
    "DUAL-MODE_LOOP",
    "OUTPUT",
    "CARTESIAN_IMAGE_ANALYSIS_APPENDIX",
    "ANTI-DRIFT_GUARDS",
    "TOOL_POLICY",
    "FAST_PATHS",
    "FAILURE_MODES",
]

REQUIRED_OUTPUT_SUBSECTIONS: List[str] = [
    "FINAL_ANSWER",
    "REASONING",
    "CHECKS",
    "OUTPUT_ASSUMPTIONS",
    "OUTPUT_COUNTERFACTUALS",
    "CONFIDENCE",
    "REASONING_LOG",
]

HEADER_RX = re.compile(r"^<\|([A-Z0-9_\-]+)\|>$")
STRICT_OUTPUT_SET = set(REQUIRED_OUTPUT_SUBSECTIONS)

# ======= ERRORS =======

class EnforceError(Exception): ...
class FormatError(EnforceError): ...
class OrderError(EnforceError): ...
class DriftError(EnforceError): ...
class MissingError(EnforceError): ...
class ExcessError(EnforceError): ...

# ======= UTIL =======

def _strip_crlf(s: str) -> str:
    return s.replace("\r\n", "\n").replace("\r", "\n")

def _find_headers(lines: List[str]) -> List[int]:
    return [i for i, ln in enumerate(lines) if HEADER_RX.match(ln)]

def _extract_header_name(line: str) -> str:
    m = HEADER_RX.match(line)
    if not m:
        raise FormatError(f"Bad header syntax: {line!r}")
    return m.group(1)

# ======= CORE ENFORCER =======

@dataclass
class EnforcementReport:
    ok: bool
    errors: List[str]
    details: Dict[str, Any]

class AntimatterBomb:
    """
    Absolute, format-first, zero-wiggle enforcement.
    - NOTHING may precede <|FINAL_ANSWER|> and its single-line payload.
    - OUTPUT headers must appear in EXACT order with NO extras.
    - No unknown headers are allowed anywhere.
    - No omitted sections allowed.
    - No “helpful” prose between headers.
    - Section order is immutable.
    """

    def __init__(self) -> None:
        # build an allowed header set to annihilate drift
        self.allowed_headers = set(REQUIRED_SECTION_ORDER) | STRICT_OUTPUT_SET

    # ---------- PUBLIC API ----------
    def enforce(self, text: str) -> EnforcementReport:
        text = _strip_crlf(text).strip("\n")
        lines = text.split("\n")
        errors: List[str] = []
        details: Dict[str, Any] = {}

        # 1) Require first header be EXACTLY <|FINAL_ANSWER|>
        if not lines:
            raise MissingError("Empty output.")
        if not HEADER_RX.match(lines[0]) or _extract_header_name(lines[0]) != "FINAL_ANSWER":
            raise OrderError("First line must be <|FINAL_ANSWER|>.")
        # 2) Require FINAL_ANSWER payload is EXACTLY one non-header line
        if len(lines) < 2 or HEADER_RX.match(lines[1]):
            raise FormatError("FINAL_ANSWER must be followed by exactly one non-header line.")
        final_answer = lines[1]
        # The next line MUST be a header
        if len(lines) < 3 or not HEADER_RX.match(lines[2]):
            raise FormatError("No text allowed after FINAL_ANSWER payload except the next header.")

        # 3) Validate OUTPUT block exact ordering and exclusivity
        # Gather headers and their blocks
        header_idxs = _find_headers(lines)
        headers = [_extract_header_name(lines[i]) for i in header_idxs]
        details["headers"] = headers

        # Ensure no unknown headers exist
        unknown = [h for h in headers if h not in self.allowed_headers]
        if unknown:
            raise DriftError(f"Unknown headers present: {unknown}")

        # Ensure OUTPUT subsections appear exactly once and in order
        output_seq = []
        for i, idx in enumerate(header_idxs):
            name = headers[i]
            # collect only OUTPUT subtree headers
            if name in STRICT_OUTPUT_SET:
                output_seq.append(name)
        if output_seq != REQUIRED_OUTPUT_SUBSECTIONS:
            raise OrderError(f"OUTPUT headers out of order or missing. Found {output_seq}, required {REQUIRED_OUTPUT_SUBSECTIONS}")

        # Ensure each OUTPUT subsection has at least one non-header line payload
        for name in REQUIRED_OUTPUT_SUBSECTIONS:
            # find its start
            start_idx = next(i for i, h in enumerate(headers) if h == name)
            start_line = header_idxs[start_idx]
            end_line = header_idxs[start_idx + 1] if start_idx + 1 < len(header_idxs) else len(lines)
            payload = lines[start_line + 1:end_line]
            if not payload:
                raise MissingError(f"{name} has no payload.")
            # Disallow nested headers in payload
            if any(HEADER_RX.match(x) for x in payload):
                raise FormatError(f"{name} payload contains a header. Not allowed.")
            # Disallow empty-only payloads
            if all(x.strip() == "" for x in payload):
                raise MissingError(f"{name} payload is empty.")

        # 4) Global: no prose lines are allowed between headers except payload lines
        # Already guaranteed by structure checks above.

        # 5) Ensure REQUIRED_SECTION_ORDER headers exist (at least once) in global stream and in order
        # They may have their own internal structure; we only verify ordering presence
        # Note: these are logical sections, not necessarily directly printed; if they are printed as headers, enforce order
        seq_positions = []
        for sec in REQUIRED_SECTION_ORDER:
            if sec in headers:
                seq_positions.append(headers.index(sec))
            else:
                # If a logical section is not printed, that is a policy choice;
                # if you want them MANDATORY, uncomment the next line.
                # raise MissingError(f"Required section missing: {sec}")
                pass
        if seq_positions != sorted(seq_positions):
            raise OrderError("Logical sections appear out of order.")

        # 6) No text allowed before <|FINAL_ANSWER|> — already enforced by start checks.

        # 7) Kill any “extra” sections that try to sneak in around OUTPUT or after it
        # i.e., headers not in allowed set were caught; nothing else to do.

        return EnforcementReport(
            ok=True,
            errors=errors,
            details={
                "final_answer": final_answer,
                "headers": headers,
                "validated_output_order": REQUIRED_OUTPUT_SUBSECTIONS,
                "validated_section_order": REQUIRED_SECTION_ORDER,
            },
        )

# ======= ONE-CALL HELPER =======

def nuke_or_raise(text: str) -> Dict[str, Any]:
    """
    Run the Antimatter Bomb. If anything deviates, raise a fatal error.
    Returns parsed report dict on success.
    """
    bomb = AntimatterBomb()
    rep = bomb.enforce(text)
    if not rep.ok or rep.errors:
        raise EnforceError({"ok": rep.ok, "errors": rep.errors, "details": rep.details})
    return {"ok": True, "details": rep.details}

# ======= DEMO (remove if embedding) =======
if __name__ == "__main__":
    SAMPLE_OK = """<|FINAL_ANSWER|>
7
<|REASONING|>
counted under locked metric, then verified
<|CHECKS|>
audit log here
<|OUTPUT_ASSUMPTIONS|>
assumptions here
<|OUTPUT_COUNTERFACTUALS|>
counterfacts here
<|CONFIDENCE|>
High
<|REASONING_LOG|>
linear steps
"""
    try:
        print(nuke_or_raise(SAMPLE_OK))
    except Exception as e:
        print("FAIL:", e)
```
